using System;
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json;

class Program
{
    public class FileLocation
    {
        public string Name { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public Location StartLoc { get; set; }
        public Location EndLoc { get; set; }
    }

    public class Location
    {
        public int Line { get; set; }
        public int Column { get; set; }
        public int Position { get; set; }
    }

    public class Duplicate
    {
        public string Format { get; set; }
        public int Lines { get; set; }
        public string Fragment { get; set; }
        public int Tokens { get; set; }
        public FileLocation FirstFile { get; set; }
        public FileLocation SecondFile { get; set; }
    }

    public class JsonData
    {
        public List<Duplicate> Duplicates { get; set; }
    }

    static void Main(string[] args)
    {
        string filePath = "path_to_your_json_file.json";  // Specify your JSON file path here
        var jsonData = ReadJsonFile(filePath);
        
        var clones = FindClones(jsonData.Duplicates);
        var reusableComponents = FindReusableComponents(jsonData.Duplicates);
        var falsePositives = DetectFalsePositives(jsonData.Duplicates);

        // Display Clones
        Console.WriteLine("Found Clones:");
        foreach (var clone in clones)
        {
            Console.WriteLine($"Fragment: {clone.Fragment.Substring(0, 50)}...");
            Console.WriteLine($"Occurrences: {clone.Value.Count}");
            foreach (var item in clone.Value)
            {
                Console.WriteLine($"  First File: {item.FirstFile.Name} -> Second File: {item.SecondFile.Name}");
            }
            Console.WriteLine();
        }

        // Display Reusable Components
        Console.WriteLine("Found Reusable Components:");
        foreach (var component in reusableComponents)
        {
            Console.WriteLine($"Fragment: {component.Fragment.Substring(0, 50)}...");
            Console.WriteLine($"First File: {component.FirstFile.Name}");
            Console.WriteLine($"Second File: {component.SecondFile.Name}");
            Console.WriteLine();
        }

        // Display False Positives
        Console.WriteLine("Detected False Positives:");
        foreach (var fp in falsePositives)
        {
            Console.WriteLine($"Fragment: {fp.Fragment.Substring(0, 50)}...");
            Console.WriteLine($"First File: {fp.FirstFile.Name}");
            Console.WriteLine($"Second File: {fp.SecondFile.Name}");
            Console.WriteLine();
        }
    }

    static JsonData ReadJsonFile(string filePath)
    {
        string jsonContent = File.ReadAllText(filePath);
        return JsonConvert.DeserializeObject<JsonData>(jsonContent);
    }

    static Dictionary<string, List<Duplicate>> FindClones(List<Duplicate> duplicates)
    {
        var cloneMap = new Dictionary<string, List<Duplicate>>();

        foreach (var duplication in duplicates)
        {
            string fragment = duplication.Fragment;
            if (!cloneMap.ContainsKey(fragment))
            {
                cloneMap[fragment] = new List<Duplicate>();
            }
            cloneMap[fragment].Add(duplication);
        }

        return cloneMap;
    }

    static List<Duplicate> FindReusableComponents(List<Duplicate> duplicates)
    {
        var reusableComponents = new List<Duplicate>();

        foreach (var duplication in duplicates)
        {
            if (duplication.FirstFile.Name != duplication.SecondFile.Name)
            {
                reusableComponents.Add(duplication);
            }
        }

        return reusableComponents;
    }

    static List<Duplicate> DetectFalsePositives(List<Duplicate> duplicates)
    {
        var falsePositives = new List<Duplicate>();

        foreach (var duplication in duplicates)
        {
            if (duplication.Fragment.TrimStart().StartsWith("//"))
            {
                falsePositives.Add(duplication);
            }
        }

        return falsePositives;
    }
}
