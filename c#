using System;
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json;
using System.Linq;

class Program
{
    public class FileLocation
    {
        public string Name { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public Location StartLoc { get; set; }
        public Location EndLoc { get; set; }
    }

    public class Location
    {
        public int Line { get; set; }
        public int Column { get; set; }
        public int Position { get; set; }
    }

    public class Duplicate
    {
        public string Format { get; set; }
        public int Lines { get; set; }
        public string Fragment { get; set; }
        public int Tokens { get; set; }
        public FileLocation FirstFile { get; set; }
        public FileLocation SecondFile { get; set; }
    }

    public class JsonData
    {
        public List<Duplicate> Duplicates { get; set; }
    }

    static void Main(string[] args)
    {
        string filePath = "path_to_your_json_file.json";  // Specify your JSON file path here

        // Load and process JSON file
        var jsonData = ReadJsonFile(filePath);
        Console.WriteLine("Processing duplicates...");

        // Find clones, reusable components, and false positives in parallel
        var (clones, reusableComponents, falsePositives) = ProcessDuplicates(jsonData.Duplicates);

        // Display Results
        DisplayResults("Found Clones", clones);
        DisplayResults("Found Reusable Components", reusableComponents);
        DisplayResults("Detected False Positives", falsePositives);
    }

    static JsonData ReadJsonFile(string filePath)
    {
        string jsonContent = File.ReadAllText(filePath);
        return JsonConvert.DeserializeObject<JsonData>(jsonContent);
    }

    // Efficiently processes duplicates
    static (Dictionary<string, List<Duplicate>>, List<Duplicate>, List<Duplicate>) ProcessDuplicates(List<Duplicate> duplicates)
    {
        var cloneMap = new Dictionary<string, List<Duplicate>>();
        var reusableComponents = new List<Duplicate>();
        var falsePositives = new List<Duplicate>();

        foreach (var duplication in duplicates)
        {
            // Null check for Fragment
            if (duplication.Fragment != null)
            {
                // Find clones (group by code fragment)
                if (!cloneMap.ContainsKey(duplication.Fragment))
                {
                    cloneMap[duplication.Fragment] = new List<Duplicate>();
                }
                cloneMap[duplication.Fragment].Add(duplication);
            }

            // Identify reusable components (cross-file fragments)
            if (duplication.FirstFile?.Name != duplication.SecondFile?.Name)
            {
                reusableComponents.Add(duplication);
            }

            // Detect false positives (e.g., comment-only fragments)
            if (!string.IsNullOrWhiteSpace(duplication.Fragment) && duplication.Fragment.TrimStart().StartsWith("//"))
            {
                falsePositives.Add(duplication);
            }
        }

        return (cloneMap, reusableComponents, falsePositives);
    }

    // Display results efficiently
    static void DisplayResults(string title, Dictionary<string, List<Duplicate>> result)
    {
        Console.WriteLine($"\n{title}:");
        foreach (var clone in result)
        {
            // Null check for Fragment key
            if (clone.Key != null)
            {
                Console.WriteLine($"Fragment: {clone.Key.Substring(0, Math.Min(clone.Key.Length, 50))}...");
                Console.WriteLine($"Occurrences: {clone.Value.Count}");
                foreach (var item in clone.Value)
                {
                    Console.WriteLine($"  First File: {item.FirstFile?.Name} -> Second File: {item.SecondFile?.Name}");
                }
                Console.WriteLine();
            }
        }
    }

    static void DisplayResults(string title, List<Duplicate> result)
    {
        Console.WriteLine($"\n{title}:");
        foreach (var item in result)
        {
            // Null check for Fragment
            if (item.Fragment != null)
            {
                Console.WriteLine($"Fragment: {item.Fragment.Substring(0, Math.Min(item.Fragment.Length, 50))}...");
                Console.WriteLine($"First File: {item.FirstFile?.Name}");
                Console.WriteLine($"Second File: {item.SecondFile?.Name}");
                Console.WriteLine();
            }
        }
    }
}
